name: Validate Character Submission

on:
  issues:
    types: [opened, edited]

jobs:
  validate-submission:
    runs-on: ubuntu-latest
    
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Determine issue type
        id: issue_type
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const title = context.payload.issue.title;
            const body = context.payload.issue.body || '';
            
            const isSubmission = title.includes('[Character Submission]');
            const isReport = title.startsWith('[Report]') && 
                            body.includes('**Character ID:**') && 
                            body.includes('**Reason for Report:**');
            
            core.setOutput('is_submission', isSubmission ? 'true' : 'false');
            core.setOutput('is_report', isReport ? 'true' : 'false');
            console.log('Submission:', isSubmission, 'Report:', isReport);
      
      - name: Process report
        if: steps.issue_type.outputs.is_report == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            // Add labels
            const labels = issue.labels.map(l => l.name);
            const toAdd = [];
            if (!labels.includes('report')) toAdd.push('report');
            if (!labels.includes('review-needed')) toAdd.push('review-needed');
            
            if (toAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: toAdd
              });
            }
            
            // Extract details
            const titleMatch = issue.title.match(/\[Report\]\s*(.+)/);
            const charName = titleMatch ? titleMatch[1].trim() : 'Unknown';
            
            const charIdMatch = body.match(/\*\*Character ID:\*\*\s*([^\n]+)/);
            const charId = charIdMatch ? charIdMatch[1].trim() : 'unknown';
            
            const reasonMatch = body.match(/\*\*Reason for Report:\*\*\s*```\n([\s\S]*?)\n```/);
            const reason = reasonMatch ? reasonMatch[1].trim() : body.split('\n').slice(3).join('\n').trim();
            
            const comment = `## üìã Character Report Summary

**Character:** ${charName} (\`${charId}\`)
**Reporter:** @${issue.user.login}
**Status:** üîç Pending Moderator Review

### Report Details
${reason}

---
A moderator will review this report and take appropriate action.`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
      
      - name: Process submission
        if: steps.issue_type.outputs.is_submission == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Add label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['character-submission']
            });
            
            // Check for ZIP
            const issue = context.payload.issue;
            let hasZipUrl = false;
            const zipUrlPattern = /https:\/\/github\.com\/[^)\s]+\.zip(?:\?[^)\s]+)?/;
            
            if (zipUrlPattern.test(issue.body)) {
              hasZipUrl = true;
            }
            
            if (!hasZipUrl) {
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              for (const comment of comments.data) {
                if (zipUrlPattern.test(comment.body)) {
                  hasZipUrl = true;
                  break;
                }
              }
            }
            
            if (!hasZipUrl) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '‚ùå **Submission Closed - Missing ZIP**\n\nNo ZIP file attachment found. Please attach your character package and reopen.'
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: 'closed'
              });
              return;
            }
            
            // Check format
            const body = issue.body;
            const errors = [];
            
            if (!body.includes('**Character Name')) errors.push('Missing Character Name');
            if (!body.includes('**Author')) errors.push('Missing Author');
            if (!body.includes('**Tags')) errors.push('Missing Tags');
            
            if (errors.length > 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '‚ö†Ô∏è **Issues Found**\n- ' + errors.join('\n- ')
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['needs-attention']
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '‚úÖ **Submission Valid**\n\nYour character submission looks good!'
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['validated']
              });
            }
